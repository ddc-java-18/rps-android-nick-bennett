<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: edu.cnm.deepdive.rps.model.domain, class: Ecosystem">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> *  Copyright 2023 CNM Ingenuity, Inc.</span>
<span class="source-line-no">003</span><span id="line-3"> *</span>
<span class="source-line-no">004</span><span id="line-4"> *  Licensed under the Apache License, Version 2.0 (the "License");</span>
<span class="source-line-no">005</span><span id="line-5"> *  you may not use this file except in compliance with the License.</span>
<span class="source-line-no">006</span><span id="line-6"> *  You may obtain a copy of the License at</span>
<span class="source-line-no">007</span><span id="line-7"> *</span>
<span class="source-line-no">008</span><span id="line-8"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">009</span><span id="line-9"> *</span>
<span class="source-line-no">010</span><span id="line-10"> *  Unless required by applicable law or agreed to in writing, software</span>
<span class="source-line-no">011</span><span id="line-11"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="source-line-no">012</span><span id="line-12"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="source-line-no">013</span><span id="line-13"> *  See the License for the specific language governing permissions and</span>
<span class="source-line-no">014</span><span id="line-14"> *  limitations under the License.</span>
<span class="source-line-no">015</span><span id="line-15"> */</span>
<span class="source-line-no">016</span><span id="line-16">package edu.cnm.deepdive.rps.model.domain;</span>
<span class="source-line-no">017</span><span id="line-17"></span>
<span class="source-line-no">018</span><span id="line-18">import androidx.annotation.NonNull;</span>
<span class="source-line-no">019</span><span id="line-19">import java.util.Random;</span>
<span class="source-line-no">020</span><span id="line-20">import java.util.stream.IntStream;</span>
<span class="source-line-no">021</span><span id="line-21"></span>
<span class="source-line-no">022</span><span id="line-22">/**</span>
<span class="source-line-no">023</span><span id="line-23"> * Encapsulates (for simulation) a simple intransitive ecosystem&amp;mdash;as exemplified by certain E.</span>
<span class="source-line-no">024</span><span id="line-24"> * coli ecosystems, competition between male side-blotched lizards, and the game of</span>
<span class="source-line-no">025</span><span id="line-25"> * Rock-Paper-Scissors. The ecosystem in this model supports any odd {@code int} number (at least 3)</span>
<span class="source-line-no">026</span><span id="line-26"> * of breeds, and assumes equal strength between breeds&amp;mdash;both in initial populations and in</span>
<span class="source-line-no">027</span><span id="line-27"> * competitive interactions.</span>
<span class="source-line-no">028</span><span id="line-28"> * &lt;p&gt;Key&lt;/p&gt;</span>
<span class="source-line-no">029</span><span id="line-29"> * &lt;ul&gt;&lt;li&gt;Individuals in this ecosystem do not move, but are placed in all cells of a grid (or</span>
<span class="source-line-no">030</span><span id="line-30"> * points of a lattice); this is the terrain of the ecosystem.&lt;/li&gt;</span>
<span class="source-line-no">031</span><span id="line-31"> * &lt;li&gt;In each iteration of the simulation, a random individual is selected, along with one of that</span>
<span class="source-line-no">032</span><span id="line-32"> * individual's 4 immediately adjacent neighbors (i.e., in the Von Neumann neighborhood), also</span>
<span class="source-line-no">033</span><span id="line-33"> * selected at random.&lt;/li&gt;</span>
<span class="source-line-no">034</span><span id="line-34"> * &lt;li&gt;If the two selected individuals are of the same breed, then there is no change; otherwise,</span>
<span class="source-line-no">035</span><span id="line-35"> * the loser of the competition between the two (e.g., rock losing to paper) is replaced by a copy</span>
<span class="source-line-no">036</span><span id="line-36"> * of the winner.&lt;/li&gt;</span>
<span class="source-line-no">037</span><span id="line-37"> * &lt;li&gt;Optionally, competitive interaction may be preceded (with a specified probability) by random</span>
<span class="source-line-no">038</span><span id="line-38"> * selection of two (not necessarily adjacent) individuals, with the selected individuals trading</span>
<span class="source-line-no">039</span><span id="line-39"> * locations in the terrain.&lt;/li&gt;&lt;/ul&gt;</span>
<span class="source-line-no">040</span><span id="line-40"> */</span>
<span class="source-line-no">041</span><span id="line-41">public class Ecosystem {</span>
<span class="source-line-no">042</span><span id="line-42"></span>
<span class="source-line-no">043</span><span id="line-43">  private final int initialBreedCount;</span>
<span class="source-line-no">044</span><span id="line-44">  private final int size;</span>
<span class="source-line-no">045</span><span id="line-45">  private final boolean toroidal;</span>
<span class="source-line-no">046</span><span id="line-46">  private final Random rng;</span>
<span class="source-line-no">047</span><span id="line-47">  private final int[][] terrain;</span>
<span class="source-line-no">048</span><span id="line-48">  private final int[][] safeTerrain;</span>
<span class="source-line-no">049</span><span id="line-49">  private final int[] populations;</span>
<span class="source-line-no">050</span><span id="line-50">  private final int[] safePopulations;</span>
<span class="source-line-no">051</span><span id="line-51">  private final int absorptionThreshold;</span>
<span class="source-line-no">052</span><span id="line-52">  private final Occupant attacker;</span>
<span class="source-line-no">053</span><span id="line-53">  private final Occupant defender;</span>
<span class="source-line-no">054</span><span id="line-54">  private final Occupant change;</span>
<span class="source-line-no">055</span><span id="line-55"></span>
<span class="source-line-no">056</span><span id="line-56">  private long iterationCount;</span>
<span class="source-line-no">057</span><span id="line-57">  private int currentBreedCount;</span>
<span class="source-line-no">058</span><span id="line-58">  private boolean absorbed;</span>
<span class="source-line-no">059</span><span id="line-59"></span>
<span class="source-line-no">060</span><span id="line-60">  /**</span>
<span class="source-line-no">061</span><span id="line-61">   * Initializes this instance with the specified number of breeds, terrain size, and terrain</span>
<span class="source-line-no">062</span><span id="line-62">   * topology. Since selection of individuals for competition is stochastic, a source of randomness</span>
<span class="source-line-no">063</span><span id="line-63">   * must also be provided.</span>
<span class="source-line-no">064</span><span id="line-64">   *</span>
<span class="source-line-no">065</span><span id="line-65">   * @param numBreeds Number of distinct breeds to populate the ecosystem.</span>
<span class="source-line-no">066</span><span id="line-66">   * @param size      Terrain height and width.</span>
<span class="source-line-no">067</span><span id="line-67">   * @param toroidal  Flag specifying whether terrain is toroidal (with wrapping edges) or a box</span>
<span class="source-line-no">068</span><span id="line-68">   *                  (with closed edges).</span>
<span class="source-line-no">069</span><span id="line-69">   * @param rng       Source of randomness.</span>
<span class="source-line-no">070</span><span id="line-70">   */</span>
<span class="source-line-no">071</span><span id="line-71">  public Ecosystem(int numBreeds, int size, boolean toroidal, @NonNull Random rng) {</span>
<span class="source-line-no">072</span><span id="line-72">    initialBreedCount = numBreeds;</span>
<span class="source-line-no">073</span><span id="line-73">    currentBreedCount = numBreeds;</span>
<span class="source-line-no">074</span><span id="line-74">    this.size = size;</span>
<span class="source-line-no">075</span><span id="line-75">    this.toroidal = toroidal;</span>
<span class="source-line-no">076</span><span id="line-76">    this.rng = rng;</span>
<span class="source-line-no">077</span><span id="line-77">    populations = new int[numBreeds];</span>
<span class="source-line-no">078</span><span id="line-78">    safePopulations = new int[numBreeds];</span>
<span class="source-line-no">079</span><span id="line-79">    terrain = IntStream.range(0, size)</span>
<span class="source-line-no">080</span><span id="line-80">        .mapToObj((ignoredRowIndex) -&gt;</span>
<span class="source-line-no">081</span><span id="line-81">            IntStream.range(0, size)</span>
<span class="source-line-no">082</span><span id="line-82">                .map((ignoredColIndex) -&gt; rng.nextInt(numBreeds))</span>
<span class="source-line-no">083</span><span id="line-83">                .peek((breed) -&gt; populations[breed]++)</span>
<span class="source-line-no">084</span><span id="line-84">                .toArray()</span>
<span class="source-line-no">085</span><span id="line-85">        )</span>
<span class="source-line-no">086</span><span id="line-86">        .toArray(int[][]::new);</span>
<span class="source-line-no">087</span><span id="line-87">    safeTerrain = new int[size][size];</span>
<span class="source-line-no">088</span><span id="line-88">    absorptionThreshold = size * size;</span>
<span class="source-line-no">089</span><span id="line-89">    attacker = new Occupant();</span>
<span class="source-line-no">090</span><span id="line-90">    defender = new Occupant();</span>
<span class="source-line-no">091</span><span id="line-91">    change = new Occupant();</span>
<span class="source-line-no">092</span><span id="line-92">  }</span>
<span class="source-line-no">093</span><span id="line-93"></span>
<span class="source-line-no">094</span><span id="line-94">  /**</span>
<span class="source-line-no">095</span><span id="line-95">   * Executes a single iteration of the simulation. This consists of possible random selection (with</span>
<span class="source-line-no">096</span><span id="line-96">   * likelihood specified by {@code swapProbability} of a pair of individuals to swap locations,</span>
<span class="source-line-no">097</span><span id="line-97">   * followed by random selection of an individual and one of its neighbors for competitive</span>
<span class="source-line-no">098</span><span id="line-98">   * interaction.</span>
<span class="source-line-no">099</span><span id="line-99">   *</span>
<span class="source-line-no">100</span><span id="line-100">   * @param swapProbability Probability of preceding competitive interaction by swapping a randomly</span>
<span class="source-line-no">101</span><span id="line-101">   *                        selected pair of individuals.</span>
<span class="source-line-no">102</span><span id="line-102">   * @return Flag indicating whether competitive interaction resulted in a replacement of an</span>
<span class="source-line-no">103</span><span id="line-103">   * individual ({@code true}) or no change ({@code false}).</span>
<span class="source-line-no">104</span><span id="line-104">   */</span>
<span class="source-line-no">105</span><span id="line-105">  public boolean iterate(float swapProbability) {</span>
<span class="source-line-no">106</span><span id="line-106">    boolean terrainChanged = false;</span>
<span class="source-line-no">107</span><span id="line-107">    if (!absorbed) {</span>
<span class="source-line-no">108</span><span id="line-108">      if (swapProbability &gt; 0 &amp;&amp; rng.nextFloat() &lt; swapProbability) {</span>
<span class="source-line-no">109</span><span id="line-109">        swapRandomPair();</span>
<span class="source-line-no">110</span><span id="line-110">        terrainChanged = true;</span>
<span class="source-line-no">111</span><span id="line-111">      }</span>
<span class="source-line-no">112</span><span id="line-112">      terrainChanged |= competeRandomPair();</span>
<span class="source-line-no">113</span><span id="line-113">      iterationCount++;</span>
<span class="source-line-no">114</span><span id="line-114">    }</span>
<span class="source-line-no">115</span><span id="line-115">    return terrainChanged;</span>
<span class="source-line-no">116</span><span id="line-116">  }</span>
<span class="source-line-no">117</span><span id="line-117"></span>
<span class="source-line-no">118</span><span id="line-118">  /**</span>
<span class="source-line-no">119</span><span id="line-119">   * Invokes {@link #iterate(float)} repeatedly, {@code numIteration} times, and returns the count</span>
<span class="source-line-no">120</span><span id="line-120">   * of those iterations in which a competitive interaction resulted in replacement of one</span>
<span class="source-line-no">121</span><span id="line-121">   * individual by a copy of the other.</span>
<span class="source-line-no">122</span><span id="line-122">   *</span>
<span class="source-line-no">123</span><span id="line-123">   * @param numIterations   Number of invocations of {@link #iterate(float)} to perform.</span>
<span class="source-line-no">124</span><span id="line-124">   * @param swapProbability Likelihood of a randomly selected pair of individuals trading places in</span>
<span class="source-line-no">125</span><span id="line-125">   *                        each iteration.</span>
<span class="source-line-no">126</span><span id="line-126">   * @return Number of iterations resulting in a change in population sizes.</span>
<span class="source-line-no">127</span><span id="line-127">   */</span>
<span class="source-line-no">128</span><span id="line-128">  public int iterate(int numIterations, float swapProbability) {</span>
<span class="source-line-no">129</span><span id="line-129">    int changeCount = 0;</span>
<span class="source-line-no">130</span><span id="line-130">    for (int iteration = 0; iteration &lt; numIterations &amp;&amp; !absorbed; iteration++) {</span>
<span class="source-line-no">131</span><span id="line-131">      if (iterate(swapProbability)) {</span>
<span class="source-line-no">132</span><span id="line-132">        changeCount++;</span>
<span class="source-line-no">133</span><span id="line-133">      }</span>
<span class="source-line-no">134</span><span id="line-134">    }</span>
<span class="source-line-no">135</span><span id="line-135">    return changeCount;</span>
<span class="source-line-no">136</span><span id="line-136">  }</span>
<span class="source-line-no">137</span><span id="line-137"></span>
<span class="source-line-no">138</span><span id="line-138">  /**</span>
<span class="source-line-no">139</span><span id="line-139">   * Returns the initial number of breeds in the simulation.</span>
<span class="source-line-no">140</span><span id="line-140">   */</span>
<span class="source-line-no">141</span><span id="line-141">  public int getInitialBreedCount() {</span>
<span class="source-line-no">142</span><span id="line-142">    return initialBreedCount;</span>
<span class="source-line-no">143</span><span id="line-143">  }</span>
<span class="source-line-no">144</span><span id="line-144"></span>
<span class="source-line-no">145</span><span id="line-145">  /**</span>
<span class="source-line-no">146</span><span id="line-146">   * Returns the current extant (surviving) number of breeds in the simulation.</span>
<span class="source-line-no">147</span><span id="line-147">   */</span>
<span class="source-line-no">148</span><span id="line-148">  public int getCurrentBreedCount() {</span>
<span class="source-line-no">149</span><span id="line-149">    return currentBreedCount;</span>
<span class="source-line-no">150</span><span id="line-150">  }</span>
<span class="source-line-no">151</span><span id="line-151"></span>
<span class="source-line-no">152</span><span id="line-152">  /**</span>
<span class="source-line-no">153</span><span id="line-153">   * Returns the height and width of the ecosystem's terrain.</span>
<span class="source-line-no">154</span><span id="line-154">   */</span>
<span class="source-line-no">155</span><span id="line-155">  public int getSize() {</span>
<span class="source-line-no">156</span><span id="line-156">    return size;</span>
<span class="source-line-no">157</span><span id="line-157">  }</span>
<span class="source-line-no">158</span><span id="line-158"></span>
<span class="source-line-no">159</span><span id="line-159">  /**</span>
<span class="source-line-no">160</span><span id="line-160">   * Returns a flag indicating the terrain's topology, where {@code true} denotes toroidal, and</span>
<span class="source-line-no">161</span><span id="line-161">   * {@code false} denotes a box with closed sides.</span>
<span class="source-line-no">162</span><span id="line-162">   */</span>
<span class="source-line-no">163</span><span id="line-163">  public boolean isToroidal() {</span>
<span class="source-line-no">164</span><span id="line-164">    return toroidal;</span>
<span class="source-line-no">165</span><span id="line-165">  }</span>
<span class="source-line-no">166</span><span id="line-166"></span>
<span class="source-line-no">167</span><span id="line-167">  /**</span>
<span class="source-line-no">168</span><span id="line-168">   * Returns the contents of the terrain. This is a safe copy, in the sense that any changes made to</span>
<span class="source-line-no">169</span><span id="line-169">   * it by a consumer of this method will not reflect the underlying simulation. However, for</span>
<span class="source-line-no">170</span><span id="line-170">   * simulation performance, a new copy is not made each time this method is invoked; instead, the</span>
<span class="source-line-no">171</span><span id="line-171">   * contents of the array returned by this method are overwritten each time it is invoked.</span>
<span class="source-line-no">172</span><span id="line-172">   */</span>
<span class="source-line-no">173</span><span id="line-173">  public int[][] getTerrain() {</span>
<span class="source-line-no">174</span><span id="line-174">    for (int rowIndex = 0; rowIndex &lt; size; rowIndex++) {</span>
<span class="source-line-no">175</span><span id="line-175">      System.arraycopy(terrain[rowIndex], 0, safeTerrain[rowIndex], 0, size);</span>
<span class="source-line-no">176</span><span id="line-176">    }</span>
<span class="source-line-no">177</span><span id="line-177">    return safeTerrain;</span>
<span class="source-line-no">178</span><span id="line-178">  }</span>
<span class="source-line-no">179</span><span id="line-179"></span>
<span class="source-line-no">180</span><span id="line-180">  /**</span>
<span class="source-line-no">181</span><span id="line-181">   * Returns the current sizes of the ecosystem breed populations.</span>
<span class="source-line-no">182</span><span id="line-182">   */</span>
<span class="source-line-no">183</span><span id="line-183">  public int[] getPopulations() {</span>
<span class="source-line-no">184</span><span id="line-184">    System.arraycopy(populations, 0, safePopulations, 0, initialBreedCount);</span>
<span class="source-line-no">185</span><span id="line-185">    return safePopulations;</span>
<span class="source-line-no">186</span><span id="line-186">  }</span>
<span class="source-line-no">187</span><span id="line-187"></span>
<span class="source-line-no">188</span><span id="line-188">  /**</span>
<span class="source-line-no">189</span><span id="line-189">   * Returns the number of iterations performed so far in the simulation.</span>
<span class="source-line-no">190</span><span id="line-190">   */</span>
<span class="source-line-no">191</span><span id="line-191">  public long getIterationCount() {</span>
<span class="source-line-no">192</span><span id="line-192">    return iterationCount;</span>
<span class="source-line-no">193</span><span id="line-193">  }</span>
<span class="source-line-no">194</span><span id="line-194"></span>
<span class="source-line-no">195</span><span id="line-195">  /**</span>
<span class="source-line-no">196</span><span id="line-196">   * Returns a flag indicating whether the simulation has reached the absorbing state, in which only</span>
<span class="source-line-no">197</span><span id="line-197">   * one breed remains.</span>
<span class="source-line-no">198</span><span id="line-198">   */</span>
<span class="source-line-no">199</span><span id="line-199">  public boolean isAbsorbed() {</span>
<span class="source-line-no">200</span><span id="line-200">    return absorbed;</span>
<span class="source-line-no">201</span><span id="line-201">  }</span>
<span class="source-line-no">202</span><span id="line-202"></span>
<span class="source-line-no">203</span><span id="line-203">  private void swapRandomPair() {</span>
<span class="source-line-no">204</span><span id="line-204">    randomize(attacker);</span>
<span class="source-line-no">205</span><span id="line-205">    do {</span>
<span class="source-line-no">206</span><span id="line-206">      randomize(defender);</span>
<span class="source-line-no">207</span><span id="line-207">    } while (attacker.getRow() == defender.getRow()</span>
<span class="source-line-no">208</span><span id="line-208">        &amp;&amp; attacker.getColumn() == defender.getColumn());</span>
<span class="source-line-no">209</span><span id="line-209">    terrain[attacker.getRow()][attacker.getColumn()] = defender.getBreed();</span>
<span class="source-line-no">210</span><span id="line-210">    terrain[defender.getRow()][defender.getColumn()] = attacker.getBreed();</span>
<span class="source-line-no">211</span><span id="line-211">  }</span>
<span class="source-line-no">212</span><span id="line-212"></span>
<span class="source-line-no">213</span><span id="line-213">  private boolean competeRandomPair() {</span>
<span class="source-line-no">214</span><span id="line-214">    randomize(attacker);</span>
<span class="source-line-no">215</span><span id="line-215">    Direction direction;</span>
<span class="source-line-no">216</span><span id="line-216">    int defenderRow;</span>
<span class="source-line-no">217</span><span id="line-217">    int defenderColumn;</span>
<span class="source-line-no">218</span><span id="line-218">    do {</span>
<span class="source-line-no">219</span><span id="line-219">      direction = Direction.random(rng);</span>
<span class="source-line-no">220</span><span id="line-220">      defenderRow = attacker.getRow() + direction.rowOffset;</span>
<span class="source-line-no">221</span><span id="line-221">      defenderColumn = attacker.getColumn() + direction.columnOffset;</span>
<span class="source-line-no">222</span><span id="line-222">    } while (!isInBounds(defenderRow, defenderColumn));</span>
<span class="source-line-no">223</span><span id="line-223">    if (toroidal) {</span>
<span class="source-line-no">224</span><span id="line-224">      defenderRow = normalize(defenderRow);</span>
<span class="source-line-no">225</span><span id="line-225">      defenderColumn = normalize(defenderColumn);</span>
<span class="source-line-no">226</span><span id="line-226">    }</span>
<span class="source-line-no">227</span><span id="line-227">    int defenderBreed = terrain[defenderRow][defenderColumn];</span>
<span class="source-line-no">228</span><span id="line-228">    defender.set(defenderRow, defenderColumn, defenderBreed);</span>
<span class="source-line-no">229</span><span id="line-229">    int comparison = compare(attacker.getBreed(), defender.getBreed());</span>
<span class="source-line-no">230</span><span id="line-230">    boolean changed = true;</span>
<span class="source-line-no">231</span><span id="line-231">    if (comparison &lt; 0) {</span>
<span class="source-line-no">232</span><span id="line-232">      change.setFrom(attacker);</span>
<span class="source-line-no">233</span><span id="line-233">      change.setBreed(defenderBreed);</span>
<span class="source-line-no">234</span><span id="line-234">      update();</span>
<span class="source-line-no">235</span><span id="line-235">    } else if (comparison &gt; 0) {</span>
<span class="source-line-no">236</span><span id="line-236">      change.setFrom(defender);</span>
<span class="source-line-no">237</span><span id="line-237">      change.setBreed(attacker.getBreed());</span>
<span class="source-line-no">238</span><span id="line-238">      update();</span>
<span class="source-line-no">239</span><span id="line-239">    } else {</span>
<span class="source-line-no">240</span><span id="line-240">      changed = false;</span>
<span class="source-line-no">241</span><span id="line-241">    }</span>
<span class="source-line-no">242</span><span id="line-242">    return changed;</span>
<span class="source-line-no">243</span><span id="line-243">  }</span>
<span class="source-line-no">244</span><span id="line-244"></span>
<span class="source-line-no">245</span><span id="line-245">  private boolean isInBounds(int row, int column) {</span>
<span class="source-line-no">246</span><span id="line-246">    return toroidal || (row &gt;= 0 &amp;&amp; row &lt; size &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; size);</span>
<span class="source-line-no">247</span><span id="line-247">  }</span>
<span class="source-line-no">248</span><span id="line-248"></span>
<span class="source-line-no">249</span><span id="line-249">  private void randomize(Occupant occupant) {</span>
<span class="source-line-no">250</span><span id="line-250">    int row = rng.nextInt(size);</span>
<span class="source-line-no">251</span><span id="line-251">    int column = rng.nextInt(size);</span>
<span class="source-line-no">252</span><span id="line-252">    occupant.setRow(row);</span>
<span class="source-line-no">253</span><span id="line-253">    occupant.setColumn(column);</span>
<span class="source-line-no">254</span><span id="line-254">    occupant.setBreed(terrain[row][column]);</span>
<span class="source-line-no">255</span><span id="line-255">  }</span>
<span class="source-line-no">256</span><span id="line-256"></span>
<span class="source-line-no">257</span><span id="line-257">  private int normalize(int dimension) {</span>
<span class="source-line-no">258</span><span id="line-258">    dimension %= size;</span>
<span class="source-line-no">259</span><span id="line-259">    return (dimension &lt; 0) ? (dimension + size) : dimension;</span>
<span class="source-line-no">260</span><span id="line-260">  }</span>
<span class="source-line-no">261</span><span id="line-261"></span>
<span class="source-line-no">262</span><span id="line-262">  private int compare(int attackerBreed, int defenderBreed) {</span>
<span class="source-line-no">263</span><span id="line-263">    int distance = attackerBreed - defenderBreed;</span>
<span class="source-line-no">264</span><span id="line-264">    if (distance &lt; 0) {</span>
<span class="source-line-no">265</span><span id="line-265">      distance += initialBreedCount;</span>
<span class="source-line-no">266</span><span id="line-266">    }</span>
<span class="source-line-no">267</span><span id="line-267">    return initialBreedCount - 2 * distance;</span>
<span class="source-line-no">268</span><span id="line-268">  }</span>
<span class="source-line-no">269</span><span id="line-269"></span>
<span class="source-line-no">270</span><span id="line-270">  private void update() {</span>
<span class="source-line-no">271</span><span id="line-271">    int winningBreed = change.getBreed();</span>
<span class="source-line-no">272</span><span id="line-272">    int losingBreed = terrain[change.getRow()][change.getColumn()];</span>
<span class="source-line-no">273</span><span id="line-273">    terrain[change.getRow()][change.getColumn()] = winningBreed;</span>
<span class="source-line-no">274</span><span id="line-274">    if (--populations[losingBreed] &lt;= 0) {</span>
<span class="source-line-no">275</span><span id="line-275">      currentBreedCount--;</span>
<span class="source-line-no">276</span><span id="line-276">    }</span>
<span class="source-line-no">277</span><span id="line-277">    if (++populations[winningBreed] &gt;= absorptionThreshold) {</span>
<span class="source-line-no">278</span><span id="line-278">      absorbed = true;</span>
<span class="source-line-no">279</span><span id="line-279">    }</span>
<span class="source-line-no">280</span><span id="line-280">  }</span>
<span class="source-line-no">281</span><span id="line-281"></span>
<span class="source-line-no">282</span><span id="line-282">  private static class Occupant {</span>
<span class="source-line-no">283</span><span id="line-283"></span>
<span class="source-line-no">284</span><span id="line-284">    private int row;</span>
<span class="source-line-no">285</span><span id="line-285">    private int column;</span>
<span class="source-line-no">286</span><span id="line-286">    private int breed;</span>
<span class="source-line-no">287</span><span id="line-287"></span>
<span class="source-line-no">288</span><span id="line-288">    public void setFrom(Occupant other) {</span>
<span class="source-line-no">289</span><span id="line-289">      set(other.row, other.column, other.breed);</span>
<span class="source-line-no">290</span><span id="line-290">    }</span>
<span class="source-line-no">291</span><span id="line-291"></span>
<span class="source-line-no">292</span><span id="line-292">    public void set(int row, int column, int breed) {</span>
<span class="source-line-no">293</span><span id="line-293">      this.row = row;</span>
<span class="source-line-no">294</span><span id="line-294">      this.column = column;</span>
<span class="source-line-no">295</span><span id="line-295">      this.breed = breed;</span>
<span class="source-line-no">296</span><span id="line-296">    }</span>
<span class="source-line-no">297</span><span id="line-297"></span>
<span class="source-line-no">298</span><span id="line-298">    public int getRow() {</span>
<span class="source-line-no">299</span><span id="line-299">      return row;</span>
<span class="source-line-no">300</span><span id="line-300">    }</span>
<span class="source-line-no">301</span><span id="line-301"></span>
<span class="source-line-no">302</span><span id="line-302">    public void setRow(int row) {</span>
<span class="source-line-no">303</span><span id="line-303">      this.row = row;</span>
<span class="source-line-no">304</span><span id="line-304">    }</span>
<span class="source-line-no">305</span><span id="line-305"></span>
<span class="source-line-no">306</span><span id="line-306">    public int getColumn() {</span>
<span class="source-line-no">307</span><span id="line-307">      return column;</span>
<span class="source-line-no">308</span><span id="line-308">    }</span>
<span class="source-line-no">309</span><span id="line-309"></span>
<span class="source-line-no">310</span><span id="line-310">    public void setColumn(int column) {</span>
<span class="source-line-no">311</span><span id="line-311">      this.column = column;</span>
<span class="source-line-no">312</span><span id="line-312">    }</span>
<span class="source-line-no">313</span><span id="line-313"></span>
<span class="source-line-no">314</span><span id="line-314">    public int getBreed() {</span>
<span class="source-line-no">315</span><span id="line-315">      return breed;</span>
<span class="source-line-no">316</span><span id="line-316">    }</span>
<span class="source-line-no">317</span><span id="line-317"></span>
<span class="source-line-no">318</span><span id="line-318">    public void setBreed(int breed) {</span>
<span class="source-line-no">319</span><span id="line-319">      this.breed = breed;</span>
<span class="source-line-no">320</span><span id="line-320">    }</span>
<span class="source-line-no">321</span><span id="line-321"></span>
<span class="source-line-no">322</span><span id="line-322">  }</span>
<span class="source-line-no">323</span><span id="line-323"></span>
<span class="source-line-no">324</span><span id="line-324">  private enum Direction {</span>
<span class="source-line-no">325</span><span id="line-325">    NORTH(-1, 0),</span>
<span class="source-line-no">326</span><span id="line-326">    EAST(0, 1),</span>
<span class="source-line-no">327</span><span id="line-327">    SOUTH(1, 0),</span>
<span class="source-line-no">328</span><span id="line-328">    WEST(0, -1);</span>
<span class="source-line-no">329</span><span id="line-329"></span>
<span class="source-line-no">330</span><span id="line-330">    private final int rowOffset;</span>
<span class="source-line-no">331</span><span id="line-331">    private final int columnOffset;</span>
<span class="source-line-no">332</span><span id="line-332"></span>
<span class="source-line-no">333</span><span id="line-333">    Direction(int rowOffset, int columnOffset) {</span>
<span class="source-line-no">334</span><span id="line-334">      this.rowOffset = rowOffset;</span>
<span class="source-line-no">335</span><span id="line-335">      this.columnOffset = columnOffset;</span>
<span class="source-line-no">336</span><span id="line-336">    }</span>
<span class="source-line-no">337</span><span id="line-337"></span>
<span class="source-line-no">338</span><span id="line-338">    public static Direction random(Random rng) {</span>
<span class="source-line-no">339</span><span id="line-339">      Direction[] values = values();</span>
<span class="source-line-no">340</span><span id="line-340">      return values[rng.nextInt(values.length)];</span>
<span class="source-line-no">341</span><span id="line-341">    }</span>
<span class="source-line-no">342</span><span id="line-342"></span>
<span class="source-line-no">343</span><span id="line-343">  }</span>
<span class="source-line-no">344</span><span id="line-344"></span>
<span class="source-line-no">345</span><span id="line-345">}</span>




























































</pre>
</div>
</main>
</body>
</html>
